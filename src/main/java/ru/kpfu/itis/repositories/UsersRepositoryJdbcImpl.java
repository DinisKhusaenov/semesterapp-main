package ru.kpfu.itis.repositories;

import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import ru.kpfu.itis.exceptions.DuplicateEntryException;
import ru.kpfu.itis.exceptions.WrongEmailOrPasswordException;
import ru.kpfu.itis.form.LoginForm;
import ru.kpfu.itis.form.UserForm;
import ru.kpfu.itis.models.User;

import javax.servlet.http.Cookie;
import javax.sql.DataSource;
import java.sql.*;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static ru.kpfu.itis.queries.UserQueries.*;

public class UsersRepositoryJdbcImpl implements UsersRepository {

    private final DataSource dataSource;
    private final SimpleJdbcTemplate template;
    private final PasswordEncoder encoder;

    private final RowMapper<User> userRowMapper = row -> User.builder()
            .id(row.getLong("id"))
            .firstName(row.getString("first_name"))
            .lastName(row.getString("last_name"))
            .email(row.getString("email"))
            .hashPassword(row.getString("hash_password"))
            .deputies_id(row.getInt("deputies_id"))
            .build();

    public UsersRepositoryJdbcImpl(DataSource dataSource) {
        this.dataSource = dataSource;
        this.template = new SimpleJdbcTemplate(dataSource);
        this.encoder = new BCryptPasswordEncoder();
    }

    @Override
    public void signUp(UserForm userForm) throws DuplicateEntryException {
        Optional<User> userOptional = findOneByEmail(userForm.getEmail());
        // if the user is not find in the DB, allow registration
        if (!userOptional.isPresent()) {
            User user = User.builder()
                    .firstName(userForm.getFirstName())
                    .lastName(userForm.getLastName())
                    .email(userForm.getEmail())
                    .hashPassword(encoder.encode(userForm.getPassword()))
                    .build();
            save(user);
        } else throw new DuplicateEntryException();
    }

    public void updateDeputiesIdByID(Long deputies_id, Long id) {
        template.update(SQL_UPDATE_DEPUTIESID_BY_ID, deputies_id, id);
    }

    @Override
    public Cookie signIn(LoginForm loginForm) throws WrongEmailOrPasswordException {
        Optional<User> userOptional = findOneByEmail(loginForm.getEmail());
        Cookie cookie = null;
        if (userOptional.isPresent()) {
            User user = userOptional.get();
            String cookieValue = UUID.randomUUID().toString();
            System.out.println(cookieValue);
            cookie = new Cookie("auth", cookieValue);
            cookie.setMaxAge(10 * 60 * 60);
            if (!encoder.matches(loginForm.getPassword(), user.getHashPassword())) {
                throw new WrongEmailOrPasswordException();
            }
        } else throw new WrongEmailOrPasswordException();
        return cookie;
    }

    @Override
    public void save(User entity) {
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(SQL_INSERT, Statement.RETURN_GENERATED_KEYS)) {

            int i = 1;
            preparedStatement.setString(i++, entity.getFirstName());
            preparedStatement.setString(i++, entity.getLastName());
            preparedStatement.setString(i++, entity.getEmail());
            preparedStatement.setString(i, entity.getHashPassword());

            preparedStatement.executeUpdate();

            // setting the ID value generated by the database
            try (ResultSet resultSet = preparedStatement.getGeneratedKeys()) {
                resultSet.next();
                Long id = resultSet.getLong(1);
                entity.setId(id);
            }
        } catch (SQLException e) {
            throw new IllegalStateException(e);
        }
    }

    @Override
    public void update(User entity) {
        template.update(SQL_UPDATE_BY_ID, entity.getFirstName(),
                entity.getLastName(), entity.getEmail(), entity.getId());
    }

    @Override
    public void delete(User entity) {
        template.update(SQL_DELETE_BY_ID, entity.getId());
    }

    @Override
    public void deleteByEmail(String email) {
        template.update(SQL_DELETE_BY_EMAIL, email);
    }

    @Override
    public void updateByEmail(String firstName, String lastName, String email) {
        template.update(SQL_UPDATE_BY_EMAIL, firstName, lastName, email, email);
    }

    @Override
    public Optional<User> findById(Long id) {
        // this query will return list with only one user.
        // findAny returns this user.
        return template.queryForList(SQL_SELECT_BY_ID, userRowMapper, id).stream().findAny();
    }

    @Override
    public Optional<User> findOneByEmail(String email) {
        // this query will return list with only one user.
        // findAny returns this user.
        return template.queryForList(SQL_SELECT_BY_EMAIL, userRowMapper, email).stream().findAny();
    }

    @Override
    public List<User> findAll() {
        return template.queryForList(SQL_SELECT, userRowMapper);
    }


}
